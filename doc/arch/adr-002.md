# ADR 002: Locating non-conforming values in context (with conformers)

## Context

Expound currently has code to highlight the non-conforming value (NCV) within a larger value (the "context"). For instance, given the context `{:city "Denver", :state :CO}` with a spec requiring both city and state to be strings, Expound will print out:

```
   {:city ..., :state :CO}
                      ^^^

 should satisfy

   string?
```

However, the current solution requires that the non-conforming value exists atomically in the context. This assumption is not true if the spec uses a `conformer` to modify the value.

For instance, it is possible to use a conformer to verify a string with a regex spec:

```clojure
(s/def ::string-AB-seq (s/cat :a #{\A} :b #{\B}))

(s/def ::string-AB
  (s/and
   ; conform as sequence (seq function)
   (s/conformer seq)
   ; re-use previous sequence spec
   ::string-AB-seq))

(s/conform ::string-AB "AC")
```

In this case, the NCV is `\C` but context will not actually contain the character as an atomic value.

### How are conformers used in practice?

Since conformers are [not intended to be used for coercion](https://dev.clojure.org/jira/browse/CLJ-2116?focusedCommentId=45123&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-45123), in which cases might we use conformers?

- As mentioned above, treating string as regex
- Treating string as collection of values, e.g. collection of pos-ints (this is less powerful, but perhaps more succinct than a regex)
- A string which actually represents a simple int (no collection)
- An int which should be string (e.g. an ID)
- Converting any collection into a set https://dev.clojure.org/jira/browse/CLJS-1919

### Existing solution

Currently we walk the data structure and compare the path at each node to the known path of the bad value. If it matches, we print replace it with a tag, which we later replace with the pretty-printed value.

## Possible solutions

### Modify the existing algorithm

We could modify the current algorithm to allow extensions to the `walk-with-path` code such that values could be walked in a custom way e.g. strings could be further walked by index of char.

In this case, the error message for the inner value is just shown to be invalid using the current error messages.

Tradeoffs
- \+ Minimal changes
- \+ We don't have a good sense of how conformers are used, so this defers work until we get more data
- \+ Works for treating single characters as invalid
- \- Not sure it would work for treating groups of characters as invalid
- \- Error message is confusing in the collection->set case (or int to string) case because the NCV won't match the type at all.
- \- Not open for extension

## Decision

We will maintain a series of Architecture Decision Records.

From the ADR blog post:

> ADRs will be numbered sequentially and monotonically. Numbers will not be reused.

> If a decision is reversed, we will keep the old one around, but mark it as superseded. (It's still relevant to know that it was the decision, but is no longer the decision.)

We will use the following outline

* Title
* Problem Statement
* Context
    * Related work (optional)
* Possible solutions (for each solution, list pros/cons)
* Decision
* Status
* Consequences

## Status

Accepted
