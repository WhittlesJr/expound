<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ADR 002: Locating non-conforming values in context (with conformers)</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Expound</span> <span class="project-version">0.6.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="adr-000.html"><div class="inner"><span>ADR 000: Using Architecure Decision Records</span></div></a></li><li class="depth-1 "><a href="adr-001.html"><div class="inner"><span>ADR 001: Configurable value printers</span></div></a></li><li class="depth-1  current"><a href="adr-002.html"><div class="inner"><span>ADR 002: Locating non-conforming values in context (with conformers)</span></div></a></li><li class="depth-1 "><a href="development.html"><div class="inner"><span>Development</span></div></a></li><li class="depth-1 "><a href="prior_art.html"><div class="inner"><span>Prior Art</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>expound</span></div></div></li><li class="depth-2"><a href="expound.alpha.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alpha</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#adr-002-locating-non-conforming-values-in-context-with-conformers-" name="adr-002-locating-non-conforming-values-in-context-with-conformers-"></a>ADR 002: Locating non-conforming values in context (with conformers)</h1>
<h2><a href="#context" name="context"></a>Context</h2>
<p>Expound currently has code to highlight the non-conforming value (NCV) within a larger value (the “context”). For instance, given the context <code>{:city "Denver", :state :CO}</code> with a spec requiring both city and state to be strings, Expound will print out:</p>
<pre><code>   {:city ..., :state :CO}
                      ^^^

 should satisfy

   string?
</code></pre>
<p>However, the current solution requires that the non-conforming value exists atomically in the context. This assumption is not true if the spec uses a <code>conformer</code> to modify the value.</p>
<p>For instance, it is possible to use a conformer to verify a string with a regex spec:</p>
<pre><code class="clojure">(s/def ::string-AB-seq (s/cat :a #{\A} :b #{\B}))

(s/def ::string-AB
  (s/and
   ;; conform as sequence (seq function)
   (s/conformer seq)
   ;; re-use previous sequence spec
   ::string-AB-seq))

(s/conform ::string-AB "AC")
</code></pre>
<p>In this case, the NCV is <code>\C</code> but context will not actually contain the character as an atomic value.</p>
<h3><a href="#how-are-conformers-used-in-practice-" name="how-are-conformers-used-in-practice-"></a>How are conformers used in practice?</h3>
<p>Since conformers are <a href="https://dev.clojure.org/jira/browse/CLJ-2116?focusedCommentId=45123&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-45123">not intended to be used for coercion</a>, how do users use conformers in practice?</p>
<ul>
  <li>As mentioned above, treating string as regex</li>
  <li>Treating string as collection of values, e.g. collection of pos-ints (this is less powerful, but perhaps more succinct than a regex)</li>
  <li>A string which actually represents a simple int (no collection)</li>
  <li>An int which should be string (e.g. an ID)</li>
  <li><a href="https://dev.clojure.org/jira/browse/CLJS-1919">Converting any collection into a set</a></li>
  <li><a href="http://cjohansen.no/a-unified-specification/">A string that really should be treated as a UUID</a></li>
</ul>
<p>It’s worth noting that the spec authors don’t intend conformers to be used in this way.</p>
<blockquote>
  <p>“The guide page intentionally does not mention conformers as we consider them to be primarily useful for writing new custom composite spec types (not for general data transformation)” - Alex Miller, #clojure-spec, Clojurians slack</p>
</blockquote>
<h3><a href="#implementation-notes" name="implementation-notes"></a>Implementation notes</h3>
<p>At least in Clojure (not sure about CLJS), we do get access to the conformer via the ‘pred’, e.g.</p>
<p><code>(clojure.spec.alpha/conformer expound.problems/numberify clojure.core/str)</code></p>
<p>but this is only in the case where the conformer is included in the pred that fails - if the conforming happens at a level “above” the final failing predicate, we don’t see it (see the example specs above)</p>
<pre><code class="clojure">(s/explain-data ::string-AB "AC")

;;  #:clojure.spec.alpha{:problems [{:path [:b], :pred #{\B}, :val \C, :via [:expound.problems/string-AB :expound.problems/string-AB-seq], :in [1]}], :spec :expound.problems/string-AB, :value "AC"}
</code></pre>
<h3><a href="#existing-solution" name="existing-solution"></a>Existing solution</h3>
<p>We recursively walk the context data structure, using the “annotated” path (one with various records like <code>KeyPathSegment</code> and <code>KeyValuePathSegment</code> to indicate when, for example, the key of a map is invalid). When we reach the end of the path (i.e. there are no more path segments to traverse), we mark the value as “relevant” meaning it is the NCV.</p>
<h2><a href="#possible-solutions" name="possible-solutions"></a>Possible solutions</h2>
<h3><a href="#modify-the-existing-algorithm" name="modify-the-existing-algorithm"></a>Modify the existing algorithm</h3>
<p>We could modify the current algorithm to allow extensions to the <code>summary-form</code> function such that values could be walked in a custom way e.g. strings could be further walked by index of char.</p>
<p>This extension point is a bit tricky, since it’s not enough to just mark the bad value, we also need to understand the position of the bad value in the context.</p>
<p><strong>Tradeoffs</strong></p>
<ul>
  <li>+ Minimal changes</li>
  <li>+ We don’t have a good sense of how conformers are used, so this defers work until we get more data</li>
  <li>+ Works for treating single characters as invalid</li>
  <li>- Premature generalization? I’m not sure this will always work</li>
  <li>- Not sure it would work for treating groups of characters as invalid</li>
  <li>- Error message is confusing in the collection-&gt;set case (or int to string) case because the NCV won’t match the type at all.</li>
  <li>- Error message is also confusing in some cases e.g. of course “a” is not an int, it’s a string, but the issue is that’s it’s not an int when passed through conformer ‘numberify’</li>
</ul>
<h3><a href="#always-walk-the-conformed-value" name="always-walk-the-conformed-value"></a>Always walk the conformed value</h3>
<p>We could conform the value first, then use the path instead of “in”</p>
<p><strong>Tradeoffs</strong></p>
<ul>
  <li>+ Easier to walk data structure, since it’s in the right structure</li>
  <li>- Harder to understand error, since data structure does not match what was entered</li>
  <li>- Very verbose in common cases like “alt” and “or”, or regex operations.</li>
</ul>
<h3><a href="#dont-support-transformations-via-conformers-but-at-least-give-a-useful-error-message" name="dont-support-transformations-via-conformers-but-at-least-give-a-useful-error-message"></a>Don’t support transformations via conformers, but at least give a useful error message</h3>
<p>If we can’t follow a path segment into a value, we could at least give a better error message.</p>
<p><strong>Tradeoffs</strong></p>
<ul>
  <li>+ Easier to understand than current error message</li>
  <li>+ Avoids trying to support an unsupported feature</li>
  <li>- Using conformers for transformation is pretty common, and I’d prefer to allow these users to use Expound</li>
  <li>- No middle ground - users can’t use Expound at all</li>
</ul>
<h3><a href="#dont-support-transformations-via-conformers-out-of-the-box-but-provide-a-multi-method-if-users-want-to-enable-this" name="dont-support-transformations-via-conformers-out-of-the-box-but-provide-a-multi-method-if-users-want-to-enable-this"></a>Don’t support transformations via conformers out of the box, but provide a multi-method if users want to enable this</h3>
<p>I think we could check a multimethod if no other patterns match - the multimethod could take the value and the index</p>
<p><strong>Tradeoffs</strong></p>
<ul>
  <li>+ Allows users who want to use conformers a path to work around the issue</li>
  <li>- Adds implementation complexity in Expound</li>
  <li>- If the value and the index are not unique (and they may not be, especially if multiple libraries are using Expound), then this strategy won’t work. We’d also need some unique identifier like the spec name or something</li>
</ul>
<h3><a href="#just-make-sure-the-specific-cases-i-know-about-dont-crash" name="just-make-sure-the-specific-cases-i-know-about-dont-crash"></a>Just make sure the specific cases I know about don’t crash</h3>
<p>Hard-code solutions for things like treating strings like regex, etc, and not support a general mechanism</p>
<p><strong>Tradeoffs</strong></p>
<ul>
  <li>+ Solves the problem for the use-cases I know about</li>
  <li>+ Allows those users to use Expound without changes</li>
  <li>- Possible long tail of one-off bugs for an unsupported use case, although I can push back on specific instances</li>
  <li>- Implmentation complexity</li>
</ul>
<h3><a href="#throw-a-more-helpful-exception-provide-an-example-replacement-for-printer" name="throw-a-more-helpful-exception-provide-an-example-replacement-for-printer"></a>Throw a more helpful exception, provide an example replacement for ‘printer’</h3>
<p><code>expound/custom-printer</code> allows users to specify a <code>:value-str-fn</code>. I could throw a more useful exception when the default <code>value-str-fn</code> fails and provide an example of a custom implementation that works with specific conformers.</p>
<p><strong>Tradeoffs</strong></p>
<ul>
  <li>+ Gives users a more understandable error out of the box</li>
  <li>+ Users who want to adapt to their custom use case can, and can share solutions</li>
  <li>- May require a breaking change to <code>value-str-fn</code> signature to include all the relevant information (probably just want to pass the annotated problem)</li>
</ul>
<h2><a href="#decision" name="decision"></a>Decision</h2>
<p>I’m going with the solution “Throw a more helpful exception, provide an example replacement for ‘printer’”.</p>
<h2><a href="#status" name="status"></a>Status</h2>
<p>Accepted</p></div></div></div></body></html>